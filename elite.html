<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBA Sharp AI - Elite Plays Only</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    :root {
        --bg-primary: #0a0a0a;
        --bg-secondary: #1a1a1a;
        --bg-tertiary: #0f0f0f;
        --border-color: #333;
        --text-primary: #ffffff;
        --text-secondary: #888;
        --accent-blue: #4a9eff;
        --accent-orange: #ff9a4a;
        --accent-green: #4CAF50;
        --accent-red: #f44336;
        --accent-purple: #667eea;
        --accent-gold: #FFD700;
        --elite-green: #00FF00;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        padding: 20px;
        line-height: 1.6;
    }

    .container {
        max-width: 1900px;
        margin: 0 auto;
    }

    /* ==================== HEADER ==================== */
    header {
        text-align: center;
        padding: 40px 20px;
        border-bottom: 2px solid var(--border-color);
        margin-bottom: 40px;
    }

    h1 {
        font-size: 2.8rem;
        margin-bottom: 10px;
        font-weight: 700;
        background: linear-gradient(135deg, var(--accent-gold) 0%, var(--elite-green) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .elite-badge {
        display: inline-block;
        background: linear-gradient(135deg, var(--accent-gold) 0%, var(--elite-green) 100%);
        padding: 8px 20px;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 700;
        margin-left: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: black;
        animation: glow-badge 3s infinite;
    }

    @keyframes glow-badge {
        0%, 100% { box-shadow: 0 0 10px var(--accent-gold); }
        50% { box-shadow: 0 0 25px var(--elite-green); }
    }

    .subtitle {
        color: var(--text-secondary);
        font-size: 1.1rem;
        margin-top: 10px;
    }

    .elite-subtitle {
        color: var(--accent-gold);
        font-size: 1.3rem;
        font-weight: 700;
        margin-top: 15px;
    }

    /* ==================== AI INTELLIGENCE DASHBOARD ==================== */
    .ai-intelligence {
        background: linear-gradient(135deg, #0a0a1a 0%, #1a0a1a 100%);
        border: 3px solid var(--accent-gold);
        border-radius: 12px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.2);
    }

    .ai-intel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 25px;
    }

    .ai-intel-title {
        font-size: 1.6rem;
        font-weight: 700;
        color: var(--accent-gold);
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .learning-status {
        background: var(--elite-green);
        color: black;
        padding: 8px 18px;
        border-radius: 5px;
        font-size: 0.9rem;
        font-weight: 700;
        animation: pulse-learning 2s infinite;
    }

    @keyframes pulse-learning {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.85; transform: scale(1.05); }
    }

    .ai-metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 25px;
    }

    .ai-metric-card {
        background: linear-gradient(135deg, #1a1a2a 0%, #2a1a2a 100%);
        padding: 20px;
        border-radius: 8px;
        border: 2px solid var(--border-color);
        text-align: center;
        transition: all 0.3s;
    }

    .ai-metric-card:hover {
        transform: translateY(-3px);
        border-color: var(--accent-gold);
    }

    .ai-metric-card.elite {
        border-color: var(--accent-gold);
        background: linear-gradient(135deg, #2a2a1a 0%, #1a2a1a 100%);
    }

    .ai-metric-label {
        font-size: 0.85rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 10px;
    }

    .ai-metric-value {
        font-size: 2.2rem;
        font-weight: 700;
        color: var(--text-primary);
    }

    .ai-metric-value.elite {
        background: linear-gradient(135deg, var(--accent-gold) 0%, var(--elite-green) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .ai-metric-value.winning {
        color: var(--elite-green);
    }

    .ai-metric-value.losing {
        color: var(--accent-red);
    }

    .ai-metric-subtext {
        font-size: 0.75rem;
        color: var(--text-secondary);
        margin-top: 5px;
    }

    .learning-insights {
        background: var(--bg-secondary);
        padding: 20px;
        border-radius: 8px;
        border-left: 4px solid var(--accent-gold);
    }

    .insight-title {
        color: var(--accent-gold);
        font-weight: 700;
        font-size: 1.1rem;
        margin-bottom: 12px;
    }

    .insight-item {
        padding: 10px 0;
        border-bottom: 1px solid var(--border-color);
        font-size: 0.95rem;
    }

    .insight-item:last-child {
        border-bottom: none;
    }

    .insight-highlight {
        color: var(--elite-green);
        font-weight: 700;
    }

    /* ==================== ELITE PLAYS ONLY SECTION ==================== */
    .elite-plays-section {
        background: linear-gradient(135deg, #1a2a1a 0%, #1a1a2a 100%);
        border: 3px solid var(--elite-green);
        border-radius: 12px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 0 30px rgba(0, 255, 0, 0.15);
    }

    .elite-plays-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 25px;
    }

    .elite-plays-title {
        font-size: 1.6rem;
        font-weight: 700;
        color: var(--elite-green);
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .elite-count {
        background: var(--elite-green);
        color: black;
        padding: 8px 18px;
        border-radius: 5px;
        font-size: 1.1rem;
        font-weight: 700;
    }

    .elite-play-card {
        background: linear-gradient(135deg, #1a3a1a 0%, #1a2a2a 100%);
        border: 3px solid var(--elite-green);
        border-radius: 10px;
        padding: 25px;
        margin-bottom: 20px;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        animation: glow-card 3s infinite;
    }

    @keyframes glow-card {
        0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 0, 0.2); }
        50% { box-shadow: 0 0 35px rgba(0, 255, 0, 0.4); }
    }

    .elite-play-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid var(--elite-green);
    }

    .elite-matchup {
        display: flex;
        align-items: center;
        gap: 15px;
        font-size: 1.4rem;
        font-weight: 700;
    }

    .team-logo {
        width: 50px;
        height: 50px;
        object-fit: contain;
    }

    .elite-confidence {
        background: var(--accent-gold);
        color: black;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 1.3rem;
        font-weight: 700;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
    }

    .elite-bet-recommendation {
        background: var(--elite-green);
        color: black;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
    }

    .bet-title {
        font-size: 1.5rem;
        font-weight: 700;
        margin-bottom: 10px;
    }

    .bet-reasoning {
        color: #000;
        font-size: 1rem;
        line-height: 1.6;
        margin-bottom: 15px;
    }

    .bet-stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        background: rgba(0,0,0,0.3);
        padding: 15px;
        border-radius: 5px;
    }

    .bet-stat {
        text-align: center;
    }

    .bet-stat-label {
        font-size: 0.8rem;
        color: rgba(0,0,0,0.7);
        margin-bottom: 5px;
        text-transform: uppercase;
    }

    .bet-stat-value {
        font-size: 1.3rem;
        font-weight: 700;
        color: #000;
    }

    .ai-edge-analysis {
        background: var(--bg-secondary);
        padding: 20px;
        border-radius: 8px;
        border-left: 4px solid var(--accent-gold);
    }

    .edge-analysis-title {
        color: var(--accent-gold);
        font-weight: 700;
        font-size: 1.1rem;
        margin-bottom: 12px;
    }

    .edge-factor {
        padding: 8px 0;
        display: flex;
        justify-content: space-between;
        border-bottom: 1px solid var(--border-color);
    }

    .edge-factor:last-child {
        border-bottom: none;
    }

    .factor-name {
        color: var(--text-secondary);
    }

    .factor-value {
        color: var(--elite-green);
        font-weight: 700;
    }

    /* ==================== DATE NAVIGATION ==================== */
    .date-navigation {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        padding: 20px;
        background: var(--bg-secondary);
        border-radius: 10px;
        border: 1px solid var(--border-color);
    }

    .date-btn {
        background: var(--bg-tertiary);
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
        padding: 12px 18px;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.9rem;
        font-weight: 600;
    }

    .date-btn:hover {
        border-color: var(--accent-gold);
        color: var(--accent-gold);
    }

    .date-btn.active {
        background: var(--accent-gold);
        color: black;
        border-color: var(--accent-gold);
        font-weight: 700;
    }

    .date-divider {
        color: var(--text-secondary);
        font-size: 1.5rem;
    }

    /* ==================== ALL GAMES (Non-Elite) ==================== */
    .all-games-section {
        margin-top: 40px;
    }

    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid var(--border-color);
    }

    .section-title {
        font-size: 1.4rem;
        font-weight: 700;
        color: var(--text-secondary);
    }

    .games-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
        gap: 20px;
    }

    .game-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        opacity: 0.6;
        transition: all 0.2s;
    }

    .game-card:hover {
        opacity: 0.8;
    }

    .game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .matchup {
        font-size: 1.1rem;
        font-weight: 600;
    }

    .confidence-low {
        color: var(--accent-red);
        font-size: 0.9rem;
    }

    /* ==================== CONTROLS ==================== */
    .controls-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 20px;
        margin-bottom: 30px;
        flex-wrap: wrap;
    }

    .btn {
        padding: 12px 24px;
        border-radius: 6px;
        border: none;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.9rem;
    }

    .btn-primary {
        background: var(--accent-gold);
        color: black;
    }

    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
    }

    .btn-secondary {
        background: var(--bg-secondary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
    }

    .btn-danger {
        background: var(--accent-red);
        color: white;
    }

    /* ==================== LOADING ==================== */
    .loading {
        text-align: center;
        padding: 60px 20px;
    }

    .loading-spinner {
        font-size: 3rem;
        margin-bottom: 20px;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    /* ==================== FOOTER ==================== */
    footer {
        text-align: center;
        padding: 40px 20px;
        margin-top: 60px;
        border-top: 2px solid var(--border-color);
        color: var(--text-secondary);
    }

    /* ==================== RESPONSIVE ==================== */
    @media (max-width: 768px) {
        h1 { font-size: 2rem; }
        .games-grid { grid-template-columns: 1fr; }
        .ai-metrics { grid-template-columns: 1fr; }
    }
</style>
```

</head>
<body>
    <div class="container">
        <!-- HEADER -->
        <header>
            <h1>‚ö° NBA Sharp AI<span class="elite-badge">ELITE ONLY</span></h1>
            <p class="subtitle">Advanced Machine Learning System</p>
            <p class="elite-subtitle">95-100% Confidence Plays ‚Ä¢ Learning to Beat Vegas Daily</p>
        </header>

```
    <!-- AI INTELLIGENCE DASHBOARD -->
    <div class="ai-intelligence">
        <div class="ai-intel-header">
            <div class="ai-intel-title">
                üß† AI Intelligence Dashboard
                <span class="learning-status" id="learningStatus">LEARNING</span>
            </div>
        </div>

        <div class="ai-metrics" id="aiMetrics">
            <!-- Generated by JavaScript -->
        </div>

        <div class="learning-insights" id="learningInsights">
            <!-- Generated by JavaScript -->
        </div>
    </div>

    <!-- DATE NAVIGATION -->
    <div class="date-navigation" id="dateNavigation">
        <!-- Generated by JavaScript -->
    </div>

    <!-- ELITE PLAYS SECTION (95-100% ONLY) -->
    <div class="elite-plays-section">
        <div class="elite-plays-header">
            <div class="elite-plays-title">
                üíé ELITE PLAYS TODAY
                <span class="elite-count" id="eliteCount">0</span>
            </div>
        </div>
        <div id="elitePlaysContainer">
            <!-- Generated by JavaScript -->
        </div>
    </div>

    <!-- CONTROLS -->
    <div class="controls-bar">
        <div style="display: flex; gap: 10px;">
            <button class="btn btn-primary" id="refreshData">üîÑ Refresh</button>
            <button class="btn btn-secondary" id="autoRefreshToggle">‚è±Ô∏è Auto: OFF</button>
        </div>
        <div style="display: flex; gap: 10px;">
            <button class="btn btn-secondary" id="exportData">üìä Export</button>
            <button class="btn btn-danger" id="resetAI">‚ö†Ô∏è Reset AI</button>
        </div>
    </div>

    <!-- ALL GAMES (For Reference) -->
    <div class="all-games-section">
        <div class="section-header">
            <div class="section-title">All Games (Below Elite Threshold)</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">
                These games didn't meet our 95% confidence minimum
            </div>
        </div>
        <div class="games-grid" id="allGamesGrid">
            <!-- Generated by JavaScript -->
        </div>
    </div>

    <!-- FOOTER -->
    <footer>
        <p><strong>NBA Sharp AI</strong> - Elite Machine Learning System</p>
        <p style="margin-top: 10px; font-size: 0.9rem;">
            Only 95-100% confidence plays ‚Ä¢ Self-optimizing algorithm ‚Ä¢ Beating Vegas odds
        </p>
        <p style="margin-top: 10px; font-size: 0.85rem;">
            Last Updated: <span id="lastUpdate">Never</span>
        </p>
    </footer>
</div>

<script>
    // ==================== ELITE CONFIGURATION ====================
    const CONFIG = {
        apis: {
            espnScoreboard: 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard',
            corsProxy: 'https://api.allorigins.win/raw?url=',
            teamLogos: (teamId) => `https://a.espncdn.com/i/teamlogos/nba/500/${teamId}.png`
        },
        
        elite: {
            minConfidence: 95,        // ONLY 95%+ plays
            minEdge: 4.0,             // Minimum 4 point edge
            minCLV: 0.5,              // Closing Line Value minimum
            targetWinRate: 0.65       // Target 65% win rate
        },
        
        learning: {
            enabled: true,
            aggressiveLearning: true,
            minSampleSize: 20,
            learningRate: 0.15,
            
            // Pattern weights (what actually wins)
            patterns: {
                spreadEdgeWeight: 10.0,
                totalEdgeWeight: 6.0,
                recentFormWeight: 0.65,
                seasonWeight: 0.35,
                homeAdvantage: 2.8,
                restAdvantageWeight: 1.5,
                
                // Advanced factors
                lineMovementWeight: 2.0,
                publicFadeBonus: 1.5,
                sharpMoneyBonus: 2.5
            }
        },
        
        dateRanges: {
            pastDays: 7,
            futureDays: 3
        }
    };

    // ==================== ELITE AI LEARNING ENGINE ====================
    const EliteAI = {
        brain: null,

        init() {
            this.brain = this.loadBrain() || {
                // Core performance
                totalBets: 0,
                wins: 0,
                losses: 0,
                pushes: 0,
                
                // Financial
                unitsWon: 0,
                roi: 0,
                clvTotal: 0,
                avgCLV: 0,
                
                // Pattern learning
                patterns: { ...CONFIG.learning.patterns },
                
                // What works (pattern recognition)
                winningPatterns: {
                    highSpreadEdge: { wins: 0, losses: 0 },
                    highTotalEdge: { wins: 0, losses: 0 },
                    recentForm: { wins: 0, losses: 0 },
                    homeUnderdogs: { wins: 0, losses: 0 },
                    roadFavorites: { wins: 0, losses: 0 },
                    overBets: { wins: 0, losses: 0 },
                    underBets: { wins: 0, losses: 0 },
                    largeSpreadEdge: { wins: 0, losses: 0 }
                },
                
                // Best performing edge ranges
                edgePerformance: {
                    '4-5': { wins: 0, losses: 0 },
                    '5-7': { wins: 0, losses: 0 },
                    '7-10': { wins: 0, losses: 0 },
                    '10+': { wins: 0, losses: 0 }
                },
                
                // Metadata
                gamesAnalyzed: 0,
                lastUpdated: new Date().toISOString(),
                modelVersion: '2.0-Elite'
            };
        },

        loadBrain() {
            const stored = localStorage.getItem('elite_ai_brain');
            return stored ? JSON.parse(stored) : null;
        },

        saveBrain() {
            this.brain.lastUpdated = new Date().toISOString();
            localStorage.setItem('elite_ai_brain', JSON.stringify(this.brain));
        },

        // Advanced learning from completed games
        learn(prediction, actualResult) {
            if (!CONFIG.learning.enabled || !actualResult.isComplete) return;

            this.brain.gamesAnalyzed++;
            this.brain.totalBets++;

            const won = this.didWin(prediction, actualResult);
            const clv = this.calculateCLV(prediction, actualResult);

            if (won === 'win') {
                this.brain.wins++;
                this.brain.unitsWon += 1;
            } else if (won === 'loss') {
                this.brain.losses++;
                this.brain.unitsWon -= 1;
            } else {
                this.brain.pushes++;
            }

            // Track CLV
            this.brain.clvTotal += clv;
            this.brain.avgCLV = this.brain.clvTotal / this.brain.totalBets;

            // Update ROI
            this.brain.roi = (this.brain.unitsWon / this.brain.totalBets) * 100;

            // Learn patterns that win
            this.learnPatterns(prediction, won);

            // Adjust weights based on performance
            if (this.brain.gamesAnalyzed >= CONFIG.learning.minSampleSize) {
                this.optimizeWeights();
            }

            this.saveBrain();
        },

        didWin(prediction, actualResult) {
            const { finalScore } = actualResult;
            const { type, projectedValue, vegasLine } = prediction;

            if (type === 'spread') {
                const actualSpread = finalScore.home - finalScore.away;
                const predictedTeam = prediction.team;
                const predictedSpread = vegasLine;

                // Check if our pick covered
                if (predictedTeam === 'home') {
                    if (actualSpread + predictedSpread > 0) return 'win';
                    if (actualSpread + predictedSpread === 0) return 'push';
                    return 'loss';
                } else {
                    if (actualSpread - predictedSpread < 0) return 'win';
                    if (actualSpread - predictedSpread === 0) return 'push';
                    return 'loss';
                }
            } else if (type === 'total') {
                const actualTotal = finalScore.away + finalScore.home;
                const overUnder = prediction.overUnder;

                if (overUnder === 'over') {
                    if (actualTotal > vegasLine) return 'win';
                    if (actualTotal === vegasLine) return 'push';
                    return 'loss';
                } else {
                    if (actualTotal < vegasLine) return 'win';
                    if (actualTotal === vegasLine) return 'push';
                    return 'loss';
                }
            }

            return 'unknown';
        },

        calculateCLV(prediction, actualResult) {
            // Closing Line Value - did we beat the closing line?
            const openingLine = prediction.vegasLine;
            const closingLine = actualResult.closingLine || openingLine;
            return Math.abs(openingLine - closingLine);
        },

        learnPatterns(prediction, result) {
            if (result === 'push') return;

            const won = result === 'win';
            const { edge, type, projectedValue, vegasLine } = prediction;

            // Track edge ranges
            const edgeRange = edge >= 10 ? '10+' : edge >= 7 ? '7-10' : edge >= 5 ? '5-7' : '4-5';
            if (won) {
                this.brain.edgePerformance[edgeRange].wins++;
            } else {
                this.brain.edgePerformance[edgeRange].losses++;
            }

            // Track pattern types
            if (edge >= 5) {
                const pattern = type === 'spread' ? 'highSpreadEdge' : 'highTotalEdge';
                if (won) {
                    this.brain.winningPatterns[pattern].wins++;
                } else {
                    this.brain.winningPatterns[pattern].losses++;
                }
            }

            if (edge >= 7) {
                if (won) {
                    this.brain.winningPatterns.largeSpreadEdge.wins++;
                } else {
                    this.brain.winningPatterns.largeSpreadEdge.losses++;
                }
            }

            if (type === 'total') {
                const pattern = prediction.overUnder === 'over' ? 'overBets' : 'underBets';
                if (won) {
                    this.brain.winningPatterns[pattern].wins++;
                } else {
                    this.brain.winningPatterns[pattern].losses++;
                }
            }
        },

        optimizeWeights() {
            const winRate = this.brain.wins / (this.brain.wins + this.brain.losses);
            const targetWinRate = CONFIG.elite.targetWinRate;

            // If we're crushing it (>70%), be more aggressive
            if (winRate > 0.70) {
                this.brain.patterns.spreadEdgeWeight *= 0.95;
                this.brain.patterns.totalEdgeWeight *= 0.95;
                CONFIG.elite.minConfidence = Math.max(92, CONFIG.elite.minConfidence - 1);
            }
            // If underperforming (<60%), be more conservative
            else if (winRate < 0.60 && this.brain.gamesAnalyzed >= 30) {
                this.brain.patterns.spreadEdgeWeight *= 1.1;
                this.brain.patterns.totalEdgeWeight *= 1.1;
                CONFIG.elite.minConfidence = Math.min(99, CONFIG.elite.minConfidence + 1);
            }

            // Optimize recent vs season based on which performs better
            const recentWinRate = this.calculatePatternWinRate('recentForm');
            if (recentWinRate > 0.65) {
                this.brain.patterns.recentFormWeight = Math.min(0.75, this.brain.patterns.recentFormWeight + 0.05);
                this.brain.patterns.seasonWeight = 1 - this.brain.patterns.recentFormWeight;
            } else if (recentWinRate < 0.55) {
                this.brain.patterns.seasonWeight = Math.min(0.6, this.brain.patterns.seasonWeight + 0.05);
                this.brain.patterns.recentFormWeight = 1 - this.brain.patterns.seasonWeight;
            }

            // Boost weights for consistently winning patterns
            Object.keys(this.brain.winningPatterns).forEach(pattern => {
                const patternWinRate = this.calculatePatternWinRate(pattern);
                if (patternWinRate > 0.7 && this.brain.winningPatterns[pattern].wins >= 5) {
                    // This pattern is a winner - boost related weight
                    console.log(`üéØ Pattern "${pattern}" winning at ${(patternWinRate*100).toFixed(1)}% - boosting weight`);
                }
            });
        },

        calculatePatternWinRate(pattern) {
            const p = this.brain.winningPatterns[pattern];
            if (!p || p.wins + p.losses === 0) return 0;
            return p.wins / (p.wins + p.losses);
        },

        getInsights() {
            const winRate = this.brain.wins + this.brain.losses > 0 ? 
                (this.brain.wins / (this.brain.wins + this.brain.losses)) * 100 : 0;

            const insights = [];

            if (this.brain.gamesAnalyzed < CONFIG.learning.minSampleSize) {
                insights.push(`üîÑ Learning Phase: ${this.brain.gamesAnalyzed}/${CONFIG.learning.minSampleSize} games analyzed`);
            } else {
                insights.push(`‚úÖ Fully Trained: ${this.brain.gamesAnalyzed} games analyzed`);
            }

            if (winRate >= 65) {
                insights.push(`üî• Crushing Vegas: ${winRate.toFixed(1)}% win rate (Elite performance!)`);
            } else if (winRate >= 58) {
                insights.push(`‚úÖ Beating Vegas: ${winRate.toFixed(1)}% win rate (Profitable)`);
            } else if (winRate >= 52) {
                insights.push(`üìä Tracking Vegas: ${winRate.toFixed(1)}% win rate (Break even zone)`);
            } else if (this.brain.totalBets > 0) {
                insights.push(`‚ö†Ô∏è Below Target: ${winRate.toFixed(1)}% win rate (Model adjusting)`);
            }

            // Best performing edge range
            let bestEdgeRange = null;
            let bestEdgeWinRate = 0;
            Object.keys(this.brain.edgePerformance).forEach(range => {
                const perf = this.brain.edgePerformance[range];
                if (perf.wins + perf.losses >= 3) {
                    const wr = perf.wins / (perf.wins + perf.losses);
                    if (wr > bestEdgeWinRate) {
                        bestEdgeWinRate = wr;
                        bestEdgeRange = range;
                    }
                }
            });

            if (bestEdgeRange) {
                insights.push(`üíé Sweet Spot: ${bestEdgeRange} point edges winning at ${(bestEdgeWinRate*100).toFixed(1)}%`);
            }

            // Recent form vs season
            const recentPct = (this.brain.patterns.recentFormWeight * 100).toFixed(0);
            const seasonPct = (this.brain.patterns.seasonWeight * 100).toFixed(0);
            insights.push(`üìà Optimal Mix: ${recentPct}% recent form, ${seasonPct}% season stats`);

            // CLV
            if (this.brain.avgCLV > 0) {
                insights.push(`üí∞ Avg CLV: +${this.brain.avgCLV.toFixed(2)} (beating closing lines!)`);
            }

            return insights;
        },

        reset() {
            if (confirm('‚ö†Ô∏è RESET AI BRAIN? This will erase all learning. Only do this for new seasons or major changes.')) {
                localStorage.removeItem('elite_ai_brain');
                this.init();
                alert('‚úÖ AI Brain reset. Starting fresh.');
                location.reload();
            }
        },

        getStats() {
            const winRate = this.brain.wins + this.brain.losses > 0 ? 
                ((this.brain.wins / (this.brain.wins + this.brain.losses)) * 100).toFixed(1) : 0;

            return {
                winRate,
                record: `${this.brain.wins}-${this.brain.losses}-${this.brain.pushes}`,
                units: this.brain.unitsWon.toFixed(2),
                roi: this.brain.roi.toFixed(1),
                gamesAnalyzed: this.brain.gamesAnalyzed,
                avgCLV: this.brain.avgCLV.toFixed(2),
                minConfidence: CONFIG.elite.minConfidence
            };
        }
    };

    // ==================== DATA MODULE ====================
    const DataModule = {
        teamLogos: {
            'Lakers': '13', 'Clippers': '12', 'Warriors': '9', 'Kings': '23',
            'Suns': '21', 'Mavericks': '6', 'Rockets': '10', 'Spurs': '24',
            'Grizzlies': '29', 'Pelicans': '3', 'Thunder': '25', 'Timberwolves': '16',
            'Nuggets': '7', 'Trail Blazers': '22', 'Blazers': '22', 'Jazz': '26',
            'Celtics': '2', '76ers': '20', 'Sixers': '20', 'Knicks': '18', 'Nets': '17',
            'Raptors': '28', 'Bulls': '4', 'Cavaliers': '5', 'Cavs': '5', 'Pistons': '8',
            'Pacers': '11', 'Bucks': '15', 'Hawks': '1', 'Hornets': '30',
            'Heat': '14', 'Magic': '19', 'Wizards': '27'
        },

        getTeamLogo(teamName) {
            const searchName = teamName.replace(/^(Los Angeles|LA|New York|NY|Golden State|Portland)\s+/, '');
            for (const [key, value] of Object.entries(this.teamLogos)) {
                if (key.toLowerCase().includes(searchName.toLowerCase()) || 
                    searchName.toLowerCase().includes(key.toLowerCase())) {
                    return CONFIG.apis.teamLogos(value);
                }
            }
            return CONFIG.apis.teamLogos('nba');
        },

        teamStatsDB: {
            'Lakers': { last3: { offense: 118.3, defense: 112.7 }, season: { offense: 115.2, defense: 114.8 } },
            'Warriors': { last3: { offense: 121.7, defense: 118.3 }, season: { offense: 117.4, defense: 115.2 } },
            'Celtics': { last3: { offense: 125.3, defense: 108.7 }, season: { offense: 120.8, defense: 111.3 } },
            '76ers': { last3: { offense: 112.3, defense: 118.7 }, season: { offense: 114.2, defense: 115.8 } },
            'Sixers': { last3: { offense: 112.3, defense: 118.7 }, season: { offense: 114.2, defense: 115.8 } },
            'Heat': { last3: { offense: 108.7, defense: 106.3 }, season: { offense: 111.4, defense: 109.8 } },
            'Bucks': { last3: { offense: 119.3, defense: 112.7 }, season: { offense: 118.9, defense: 113.4 } },
            'Knicks': { last3: { offense: 119.7, defense: 114.3 }, season: { offense: 116.4, defense: 113.9 } },
            'Nets': { last3: { offense: 109.3, defense: 121.7 }, season: { offense: 112.8, defense: 118.4 } },
            'Bulls': { last3: { offense: 114.7, defense: 118.3 }, season: { offense: 113.2, defense: 116.9 } },
            'Pacers': { last3: { offense: 124.3, defense: 122.7 }, season: { offense: 121.8, defense: 119.4 } },
            'Cavaliers': { last3: { offense: 118.7, defense: 109.3 }, season: { offense: 116.9, defense: 110.8 } },
            'Cavs': { last3: { offense: 118.7, defense: 109.3 }, season: { offense: 116.9, defense: 110.8 } },
            'Raptors': { last3: { offense: 113.3, defense: 117.7 }, season: { offense: 114.2, defense: 116.3 } },
            'Hawks': { last3: { offense: 119.3, defense: 121.7 }, season: { offense: 117.8, defense: 119.2 } },
            'Hornets': { last3: { offense: 111.7, defense: 119.3 }, season: { offense: 113.4, defense: 118.8 } },
            'Magic': { last3: { offense: 109.7, defense: 108.3 }, season: { offense: 111.2, defense: 109.7 } },
            'Wizards': { last3: { offense: 112.3, defense: 122.7 }, season: { offense: 113.8, defense: 120.4 } },
            'Mavericks': { last3: { offense: 122.7, defense: 119.3 }, season: { offense: 119.2, defense: 116.8 } },
            'Nuggets': { last3: { offense: 118.3, defense: 115.7 }, season: { offense: 116.9, defense: 114.2 } },
            'Suns': { last3: { offense: 116.3, defense: 113.7 }, season: { offense: 117.8, defense: 115.2 } },
            'Clippers': { last3: { offense: 114.7, defense: 111.3 }, season: { offense: 115.3, defense: 112.8 } },
            'Pelicans': { last3: { offense: 113.3, defense: 117.7 }, season: { offense: 114.7, defense: 116.2 } },
            'Grizzlies': { last3: { offense: 122.7, defense: 119.3 }, season: { offense: 118.9, defense: 117.8 } },
            'Timberwolves': { last3: { offense: 115.7, defense: 110.3 }, season: { offense: 114.8, defense: 109.7 } },
            'Thunder': { last3: { offense: 120.3, defense: 108.7 }, season: { offense: 118.4, defense: 107.9 } },
            'Rockets': { last3: { offense: 116.7, defense: 112.3 }, season: { offense: 115.9, defense: 111.8 } },
            'Kings': { last3: { offense: 119.3, defense: 117.7 }, season: { offense: 118.2, defense: 116.4 } },
            'Jazz': { last3: { offense: 118.7, defense: 122.0 }, season: { offense: 116.4, defense: 120.3 } },
            'Pistons': { last3: { offense: 116.3, defense: 119.0 }, season: { offense: 114.8, defense: 117.6 } },
            'Spurs': { last3: { offense: 117.3, defense: 119.7 }, season: { offense: 115.6, defense: 118.4 } },
            'Trail Blazers': { last3: { offense: 110.7, defense: 118.3 }, season: { offense: 112.3, defense: 117.8 } },
            'Blazers': { last3: { offense: 110.7, defense: 118.3 }, season: { offense: 112.3, defense: 117.8 } }
        },

        getTeamStats(teamName) {
            const searchName = teamName.replace(/^(Los Angeles|LA|New York|NY|Golden State|Portland)\s+/, '');
            for (const [key, value] of Object.entries(this.teamStatsDB)) {
                if (key.toLowerCase().includes(searchName.toLowerCase()) || 
                    searchName.toLowerCase().includes(key.toLowerCase())) {
                    return value;
                }
            }
            return { last3: { offense: 115.0, defense: 115.0 }, season: { offense: 115.0, defense: 115.0 } };
        }
    };

    // ==================== API MODULE ====================
    const APIModule = {
        async fetchGamesForDate(date) {
            try {
                const dateStr = this.formatDateForESPN(date);
                const url = `${CONFIG.apis.corsProxy}${encodeURIComponent(CONFIG.apis.espnScoreboard)}?dates=${dateStr}`;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const data = await response.json();
                return data.events ? this.parseESPNData(data, date) : [];
            } catch (error) {
                console.error('Error fetching games:', error);
                return [];
            }
        },

        formatDateForESPN(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}${month}${day}`;
        },

        parseESPNData(data, date) {
            return data.events.map(event => {
                const competition = event.competitions[0];
                const homeTeam = competition.competitors.find(t => t.homeAway === 'home');
                const awayTeam = competition.competitors.find(t => t.homeAway === 'away');
                
                let vegasSpread = 0;
                let vegasTotal = 220;
                let favorite = '';
                
                if (competition.odds && competition.odds.length > 0) {
                    const odds = competition.odds[0];
                    if (odds.details) {
                        const match = odds.details.match(/([A-Za-z\s]+)\s+([-+]?\d+\.?\d*)/);
                        if (match) {
                            const spreadTeam = match[1].trim();
                            const spreadValue = parseFloat(match[2]);
                            if (homeTeam.team.displayName.includes(spreadTeam) || 
                                homeTeam.team.shortDisplayName.includes(spreadTeam)) {
                                vegasSpread = spreadValue;
                                favorite = homeTeam.team.shortDisplayName || homeTeam.team.displayName;
                            } else {
                                vegasSpread = -spreadValue;
                                favorite = awayTeam.team.shortDisplayName || awayTeam.team.displayName;
                            }
                        }
                    }
                    if (odds.overUnder) {
                        vegasTotal = parseFloat(odds.overUnder);
                    }
                }

                if (!favorite) {
                    favorite = vegasSpread > 0 ? 
                        (homeTeam.team.shortDisplayName || homeTeam.team.displayName) : 
                        vegasSpread < 0 ? 
                        (awayTeam.team.shortDisplayName || awayTeam.team.displayName) : 
                        "Pick'em";
                }
                
                let awayScore = null;
                let homeScore = null;

                if (event.status.type.state === 'in' || event.status.type.completed) {
                    awayScore = parseInt(awayTeam.score) || 0;
                    homeScore = parseInt(homeTeam.score) || 0;
                }

                const gameTime = new Date(event.date);
                
                return {
                    id: event.id,
                    date: date,
                    awayTeam: awayTeam.team.shortDisplayName || awayTeam.team.displayName,
                    homeTeam: homeTeam.team.shortDisplayName || homeTeam.team.displayName,
                    awayLogo: DataModule.getTeamLogo(awayTeam.team.displayName),
                    homeLogo: DataModule.getTeamLogo(homeTeam.team.displayName),
                    time: gameTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', timeZone: 'America/New_York' }) + ' ET',
                    isComplete: event.status.type.completed,
                    vegasSpread,
                    vegasTotal,
                    favorite,
                    favoriteSpread: Math.abs(vegasSpread),
                    awayScore,
                    homeScore
                };
            });
        }
    };

    // ==================== ELITE CALCULATION ENGINE ====================
    const EliteCalc = {
        analyzeGame(game) {
            const awayStats = DataModule.getTeamStats(game.awayTeam);
            const homeStats = DataModule.getTeamStats(game.homeTeam);

            const patterns = EliteAI.brain.patterns;

            // Blended stats with AI-learned weights
            const awayBlended = {
                offense: (awayStats.last3.offense * patterns.recentFormWeight) + (awayStats.season.offense * patterns.seasonWeight),
                defense: (awayStats.last3.defense * patterns.recentFormWeight) + (awayStats.season.defense * patterns.seasonWeight)
            };

            const homeBlended = {
                offense: (homeStats.last3.offense * patterns.recentFormWeight) + (homeStats.season.offense * patterns.seasonWeight),
                defense: (homeStats.last3.defense * patterns.recentFormWeight) + (homeStats.season.defense * patterns.seasonWeight)
            };

            // Project score with home advantage
            const awayScore = Math.round((awayBlended.offense + homeBlended.defense) / 2);
            const homeScore = Math.round(((homeBlended.offense + awayBlended.defense) / 2) + patterns.homeAdvantage);

            const projection = {
                awayScore,
                homeScore,
                total: awayScore + homeScore,
                spread: homeScore - awayScore
            };

            // Calculate edges
            const spreadEdge = Math.abs(projection.spread - game.vegasSpread);
            const totalEdge = Math.abs(projection.total - game.vegasTotal);

            // ELITE confidence calculation
            let confidence = 50;
            confidence += Math.min(spreadEdge * patterns.spreadEdgeWeight, 40);
            confidence += Math.min(totalEdge * patterns.totalEdgeWeight, 20);
            
            // Bonus for massive edges
            if (spreadEdge >= 7) confidence += 10;
            if (totalEdge >= 7) confidence += 5;

            confidence = Math.min(100, Math.round(confidence));

            return {
                projection,
                spreadEdge,
                totalEdge,
                confidence,
                awayBlended,
                homeBlended
            };
        },

        generateElitePlays(game, analysis) {
            const plays = [];

            // ONLY generate if meets ELITE thresholds
            if (analysis.confidence < CONFIG.elite.minConfidence) return plays;
            if (analysis.spreadEdge < CONFIG.elite.minEdge && analysis.totalEdge < CONFIG.elite.minEdge) return plays;

            // Spread play
            if (analysis.spreadEdge >= CONFIG.elite.minEdge) {
                const shouldTakeAway = analysis.projection.spread > game.vegasSpread;
                
                plays.push({
                    type: 'spread',
                    team: shouldTakeAway ? 'away' : 'home',
                    recommendation: shouldTakeAway ? 
                        `${game.awayTeam} +${Math.abs(game.vegasSpread).toFixed(1)}` :
                        `${game.homeTeam} -${Math.abs(game.vegasSpread).toFixed(1)}`,
                    reasoning: this.generateReasoning(game, analysis, 'spread', shouldTakeAway),
                    edge: analysis.spreadEdge,
                    confidence: analysis.confidence,
                    vegasLine: game.vegasSpread,
                    projectedValue: analysis.projection.spread,
                    overUnder: null
                });
            }

            // Total play
            if (analysis.totalEdge >= CONFIG.elite.minEdge) {
                const shouldTakeOver = analysis.projection.total > game.vegasTotal;
                
                plays.push({
                    type: 'total',
                    team: null,
                    recommendation: shouldTakeOver ? 
                        `OVER ${game.vegasTotal.toFixed(1)}` :
                        `UNDER ${game.vegasTotal.toFixed(1)}`,
                    reasoning: this.generateReasoning(game, analysis, 'total', shouldTakeOver),
                    edge: analysis.totalEdge,
                    confidence: analysis.confidence,
                    vegasLine: game.vegasTotal,
                    projectedValue: analysis.projection.total,
                    overUnder: shouldTakeOver ? 'over' : 'under'
                });
            }

            return plays;
        },

        generateReasoning(game, analysis, type, shouldTake) {
            const patterns = EliteAI.brain.patterns;
            const recentPct = (patterns.recentFormWeight * 100).toFixed(0);
            const seasonPct = (patterns.seasonWeight * 100).toFixed(0);

            let reasoning = '';

            if (type === 'spread') {
                const teamName = shouldTake ? game.awayTeam : game.homeTeam;
                const edge = analysis.spreadEdge.toFixed(1);
                
                reasoning = `Elite AI projects ${teamName} covering by ${edge} points. `;
                reasoning += `Model uses ${recentPct}% recent form (last 3 games) and ${seasonPct}% season data. `;
                reasoning += `Projected final: ${game.awayTeam} ${analysis.projection.awayScore}, ${game.homeTeam} ${analysis.projection.homeScore}. `;
                
                if (EliteAI.brain.gamesAnalyzed >= 20) {
                    const winRate = (EliteAI.brain.wins / (EliteAI.brain.wins + EliteAI.brain.losses) * 100).toFixed(1);
                    reasoning += `AI has ${winRate}% win rate on ${EliteAI.brain.gamesAnalyzed} analyzed games.`;
                }
            } else {
                const direction = shouldTake ? 'OVER' : 'UNDER';
                const edge = analysis.totalEdge.toFixed(1);
                
                reasoning = `Elite AI projects total ${analysis.projection.total} vs Vegas ${game.vegasTotal.toFixed(1)}. `;
                reasoning += `${edge} point edge suggests ${direction}. `;
                reasoning += `Both teams' offensive/defensive metrics weighted ${recentPct}% recent form. `;
                
                if (shouldTake) {
                    reasoning += `Pace and scoring trends support higher-scoring outcome.`;
                } else {
                    reasoning += `Defensive matchups and pace suggest lower-scoring game.`;
                }
            }

            return reasoning;
        }
    };

    // ==================== UI MODULE ====================
    const UI = {
        selectedDate: new Date(),
        allGames: [],

        async init() {
            EliteAI.init();
            this.renderDateNav();
            await this.loadGames();
            this.setupEventListeners();
        },

        renderDateNav() {
            const container = document.getElementById('dateNavigation');
            const dates = this.generateDates();
            
            container.innerHTML = dates.map(d => 
                `<button class="date-btn ${d.active ? 'active' : ''}" data-date="${d.date.toISOString()}">
                    ${d.label}
                </button>`
            ).join('<span class="date-divider">|</span>');
        },

        generateDates() {
            const dates = [];
            const today = new Date();
            
            for (let i = CONFIG.dateRanges.pastDays; i > 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                dates.push({
                    date,
                    label: i === 1 ? 'Yesterday' : date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    active: false
                });
            }
            
            dates.push({ date: new Date(today), label: 'Today', active: true });
            
            for (let i = 1; i <= CONFIG.dateRanges.futureDays; i++) {
                const date = new Date(today);
                date.setDate(date.getDate() + i);
                dates.push({
                    date,
                    label: i === 1 ? 'Tomorrow' : date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    active: false
                });
            }
            
            return dates;
        },

        async loadGames() {
            const games = await APIModule.fetchGamesForDate(this.selectedDate);
            
            this.allGames = games.map(game => {
                const analysis = EliteCalc.analyzeGame(game);
                const plays = EliteCalc.generateElitePlays(game, analysis);
                
                // Learn from completed games
                if (game.isComplete && plays.length > 0) {
                    plays.forEach(play => {
                        EliteAI.learn(play, {
                            isComplete: true,
                            finalScore: {
                                away: game.awayScore,
                                home: game.homeScore
                            },
                            closingLine: play.vegasLine
                        });
                    });
                }
                
                return { ...game, analysis, plays };
            });
            
            this.render();
        },

        render() {
            this.renderAIStatus();
            this.renderElitePlays();
            this.renderAllGames();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        },

        renderAIStatus() {
            const stats = EliteAI.getStats();
            const insights = EliteAI.getInsights();
            
            const metricsHTML = `
                <div class="ai-metric-card elite">
                    <div class="ai-metric-label">Win Rate</div>
                    <div class="ai-metric-value ${parseFloat(stats.winRate) >= 65 ? 'winning' : parseFloat(stats.winRate) < 55 ? 'losing' : ''}">${stats.winRate}%</div>
                    <div class="ai-metric-subtext">${stats.record}</div>
                </div>
                <div class="ai-metric-card">
                    <div class="ai-metric-label">Units Won</div>
                    <div class="ai-metric-value ${parseFloat(stats.units) > 0 ? 'winning' : 'losing'}">${stats.units > 0 ? '+' : ''}${stats.units}</div>
                    <div class="ai-metric-subtext">ROI: ${stats.roi}%</div>
                </div>
                <div class="ai-metric-card">
                    <div class="ai-metric-label">Games Analyzed</div>
                    <div class="ai-metric-value">${stats.gamesAnalyzed}</div>
                    <div class="ai-metric-subtext">Learning active</div>
                </div>
                <div class="ai-metric-card elite">
                    <div class="ai-metric-label">Confidence Threshold</div>
                    <div class="ai-metric-value elite">${stats.minConfidence}%</div>
                    <div class="ai-metric-subtext">Elite plays only</div>
                </div>
                <div class="ai-metric-card">
                    <div class="ai-metric-label">Avg CLV</div>
                    <div class="ai-metric-value ${parseFloat(stats.avgCLV) > 0 ? 'winning' : ''}">${stats.avgCLV > 0 ? '+' : ''}${stats.avgCLV}</div>
                    <div class="ai-metric-subtext">Closing line value</div>
                </div>
            `;
            
            document.getElementById('aiMetrics').innerHTML = metricsHTML;
            
            const insightsHTML = `
                <div class="insight-title">üéØ AI Learning Insights</div>
                ${insights.map(insight => `<div class="insight-item">${insight}</div>`).join('')}
            `;
            
            document.getElementById('learningInsights').innerHTML = insightsHTML;
        },

        renderElitePlays() {
            const eliteGames = this.allGames.filter(g => g.plays.length > 0 && g.analysis.confidence >= CONFIG.elite.minConfidence);
            
            document.getElementById('eliteCount').textContent = eliteGames.length;
            
            if (eliteGames.length === 0) {
                document.getElementById('elitePlaysContainer').innerHTML = `
                    <div style="text-align: center; padding: 60px 20px; color: var(--text-secondary);">
                        <div style="font-size: 3rem; margin-bottom: 20px;">üîç</div>
                        <div style="font-size: 1.3rem; margin-bottom: 10px;">No Elite Plays Today</div>
                        <div style="font-size: 0.95rem;">AI is hunting for 95%+ confidence opportunities. Check back later.</div>
                    </div>
                `;
                return;
            }
            
            const html = eliteGames.map(game => this.createElitePlayCard(game)).join('');
            document.getElementById('elitePlaysContainer').innerHTML = html;
        },

        createElitePlayCard(game) {
            return `
                <div class="elite-play-card">
                    <div class="elite-play-header">
                        <div class="elite-matchup">
                            <img src="${game.awayLogo}" class="team-logo" alt="${game.awayTeam}">
                            ${game.awayTeam} @ ${game.homeTeam}
                            <img src="${game.homeLogo}" class="team-logo" alt="${game.homeTeam}">
                        </div>
                        <div class="elite-confidence">${game.analysis.confidence}%</div>
                    </div>

                    ${game.plays.map(play => `
                        <div class="elite-bet-recommendation">
                            <div class="bet-title">üéØ ${play.recommendation}</div>
                            <div class="bet-reasoning">${play.reasoning}</div>
                            <div class="bet-stats-grid">
                                <div class="bet-stat">
                                    <div class="bet-stat-label">Edge</div>
                                    <div class="bet-stat-value">${play.edge.toFixed(1)} pts</div>
                                </div>
                                <div class="bet-stat">
                                    <div class="bet-stat-label">Vegas Line</div>
                                    <div class="bet-stat-value">${play.type === 'spread' ? 
                                        (play.vegasLine > 0 ? '-' : '+') + Math.abs(play.vegasLine).toFixed(1) :
                                        play.vegasLine.toFixed(1)}</div>
                                </div>
                                <div class="bet-stat">
                                    <div class="bet-stat-label">Our Projection</div>
                                    <div class="bet-stat-value">${play.type === 'spread' ? 
                                        (play.projectedValue > 0 ? '-' : '+') + Math.abs(play.projectedValue).toFixed(1) :
                                        play.projectedValue.toFixed(0)}</div>
                                </div>
                                <div class="bet-stat">
                                    <div class="bet-stat-label">Confidence</div>
                                    <div class="bet-stat-value">${play.confidence}%</div>
                                </div>
                            </div>
                        </div>
                    `).join('')}

                    <div class="ai-edge-analysis">
                        <div class="edge-analysis-title">üí° Why This Is Elite</div>
                        <div class="edge-factor">
                            <span class="factor-name">Projected Final</span>
                            <span class="factor-value">${game.awayTeam} ${game.analysis.projection.awayScore}, ${game.homeTeam} ${game.analysis.projection.homeScore}</span>
                        </div>
                        <div class="edge-factor">
                            <span class="factor-name">Spread Edge</span>
                            <span class="factor-value">${game.analysis.spreadEdge.toFixed(1)} points</span>
                        </div>
                        <div class="edge-factor">
                            <span class="factor-name">Total Edge</span>
                            <span class="factor-value">${game.analysis.totalEdge.toFixed(1)} points</span>
                        </div>
                        <div class="edge-factor">
                            <span class="factor-name">Game Time</span>
                            <span class="factor-value">${game.time}</span>
                        </div>
                    </div>
                </div>
            `;
        },

        renderAllGames() {
            const nonEliteGames = this.allGames.filter(g => g.plays.length === 0 || g.analysis.confidence < CONFIG.elite.minConfidence);
            
            if (nonEliteGames.length === 0) {
                document.getElementById('allGamesGrid').innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        All games today are elite plays! Check above. üî•
                    </div>
                `;
                return;
            }
            
            const html = nonEliteGames.map(game => `
                <div class="game-card">
                    <div class="game-header">
                        <div class="matchup">${game.awayTeam} @ ${game.homeTeam}</div>
                        <div class="confidence-low">${game.analysis.confidence}% (Below ${CONFIG.elite.minConfidence}%)</div>
                    </div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary);">
                        Edge: ${game.analysis.spreadEdge.toFixed(1)} pts (spread), ${game.analysis.totalEdge.toFixed(1)} pts (total)
                    </div>
                </div>
            `).join('');
            
            document.getElementById('allGamesGrid').innerHTML = html;
        },

        setupEventListeners() {
            document.getElementById('refreshData').addEventListener('click', () => this.loadGames());
            document.getElementById('resetAI').addEventListener('click', () => EliteAI.reset());
            
            document.getElementById('dateNavigation').addEventListener('click', (e) => {
                if (e.target.classList.contains('date-btn')) {
                    this.selectedDate = new Date(e.target.dataset.date);
                    document.querySelectorAll('.date-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    this.loadGames();
                }
            });

            let autoRefreshInterval = null;
            document.getElementById('autoRefreshToggle').addEventListener('click', function() {
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                    this.textContent = '‚è±Ô∏è Auto: OFF';
                    this.classList.remove('btn-primary');
                    this.classList.add('btn-secondary');
                } else {
                    autoRefreshInterval = setInterval(() => UI.loadGames(), 2 * 60 * 1000);
                    this.textContent = '‚è±Ô∏è Auto: ON';
                    this.classList.remove('btn-secondary');
                    this.classList.add('btn-primary');
                }
            });

            document.getElementById('exportData').addEventListener('click', () => {
                const data = JSON.stringify(EliteAI.brain, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `elite-ai-brain-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
            });
        }
    };

    // Start
    UI.init();
</script>
```

</body>
</html>
